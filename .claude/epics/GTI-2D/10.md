---
name: 房间匹配和撤离系统
epic: GTI-2D
status: backlog
priority: high
estimated_hours: 24
workload: L
dependencies: ["003", "005"]
parallel: false
created: 2025-09-29T20:52:07Z
updated: 2025-09-29T21:48:53Z
---

# Task 009: 房间匹配和撤离系统

## 描述

实现9人匹配、房间管理和撤离机制，构建完整的多人对战核心系统。包括智能匹配算法、房间生命周期管理、撤离点机制和胜负判定逻辑，确保游戏的核心"搜、打、撤"玩法能够稳定运行。

## 验收标准

### 核心功能
- [ ] **匹配算法**
  - 支持9人快速匹配（3队伍，每队3人）
  - 匹配时间控制在30秒内
  - 支持等级/技能匹配度计算
  - 处理掉线重连和替补机制

- [ ] **房间生命周期**
  - 房间创建、等待、游戏中、结算、销毁完整流程
  - 房间状态实时同步给所有玩家
  - 支持房间超时自动销毁
  - 异常情况下的房间回收机制

- [ ] **撤离条件**
  - 指定撤离点位置和激活条件
  - 撤离倒计时和进度显示
  - 支持队伍部分成员撤离
  - 撤离中断和重新撤离机制

- [ ] **胜负判定**
  - 基于撤离成功和存活状态的胜负逻辑
  - 积分和奖励计算系统
  - 战绩统计和数据记录
  - 排名和评级更新

### 质量要求
- [ ] 匹配成功率 > 90%
- [ ] 房间稳定性 > 95%（无异常退出）
- [ ] 撤离判定准确率 100%
- [ ] 支持并发房间数 > 100个

## 技术要点

### 匹配算法实现
```typescript
// 匹配服务核心算法
class MatchmakingService {
  private matchingQueue: Map<string, Player> = new Map();
  private skillRange = { min: -200, max: 200 };

  async findMatch(player: Player): Promise<Room | null> {
    // 技能匹配计算
    const candidates = this.findCandidates(player);

    if (candidates.length >= 8) { // 需要8个其他玩家
      return this.createRoom(player, candidates.slice(0, 8));
    }

    // 加入匹配队列
    this.matchingQueue.set(player.id, player);
    return null;
  }

  private findCandidates(player: Player): Player[] {
    return Array.from(this.matchingQueue.values())
      .filter(p => Math.abs(p.skill - player.skill) <= this.skillRange.max)
      .sort((a, b) => Math.abs(a.skill - player.skill) - Math.abs(b.skill - player.skill));
  }
}
```

### 房间状态管理
```typescript
// 房间生命周期管理
enum RoomState {
  WAITING = 'waiting',
  STARTING = 'starting',
  IN_GAME = 'in_game',
  ENDING = 'ending',
  FINISHED = 'finished'
}

class RoomManager {
  private rooms: Map<string, GameRoom> = new Map();

  async createRoom(players: Player[]): Promise<GameRoom> {
    const room = new GameRoom(generateRoomId(), players);
    room.state = RoomState.WAITING;

    // 设置房间超时销毁
    setTimeout(() => {
      if (room.state === RoomState.WAITING) {
        this.destroyRoom(room.id);
      }
    }, 60000); // 60秒超时

    this.rooms.set(room.id, room);
    await this.notifyPlayersRoomCreated(room);
    return room;
  }

  async startGame(roomId: string): Promise<void> {
    const room = this.rooms.get(roomId);
    if (!room || room.state !== RoomState.WAITING) return;

    room.state = RoomState.STARTING;
    await this.initializeGameSession(room);
    room.state = RoomState.IN_GAME;
  }
}
```

### 撤离机制
```typescript
// 撤离点系统
class EvacuationSystem {
  private evacuationZones: EvacuationZone[] = [];
  private evacuatingPlayers: Map<string, EvacuationProgress> = new Map();

  initializeEvacuationZones(mapData: MapData): void {
    this.evacuationZones = mapData.evacuationPoints.map(point => ({
      id: point.id,
      position: point.position,
      radius: 50, // 撤离区域半径
      isActive: false,
      activationTime: 0
    }));
  }

  async startEvacuation(playerId: string, zoneId: string): Promise<boolean> {
    const zone = this.evacuationZones.find(z => z.id === zoneId);
    const player = this.getPlayer(playerId);

    if (!zone || !this.isPlayerInZone(player, zone)) {
      return false;
    }

    // 开始撤离倒计时
    const evacuation: EvacuationProgress = {
      playerId,
      zoneId,
      startTime: Date.now(),
      duration: 10000, // 10秒撤离时间
      interrupted: false
    };

    this.evacuatingPlayers.set(playerId, evacuation);
    this.startEvacuationCountdown(evacuation);
    return true;
  }

  private async startEvacuationCountdown(evacuation: EvacuationProgress): Promise<void> {
    const checkInterval = setInterval(async () => {
      const progress = this.evacuatingPlayers.get(evacuation.playerId);
      if (!progress || progress.interrupted) {
        clearInterval(checkInterval);
        return;
      }

      const elapsed = Date.now() - progress.startTime;
      if (elapsed >= progress.duration) {
        // 撤离成功
        await this.completeEvacuation(evacuation.playerId);
        clearInterval(checkInterval);
      }
    }, 100);
  }
}
```

### 胜负判定系统
```typescript
// 胜负判定和积分计算
class VictoryConditionManager {
  async evaluateGameEnd(room: GameRoom): Promise<GameResult> {
    const teams = this.groupPlayersByTeam(room.players);
    const results: TeamResult[] = [];

    for (const team of teams) {
      const evacuatedCount = team.filter(p => p.evacuated).length;
      const aliveCount = team.filter(p => p.isAlive).length;
      const totalScore = this.calculateTeamScore(team);

      results.push({
        teamId: team[0].teamId,
        evacuatedPlayers: evacuatedCount,
        survivingPlayers: aliveCount,
        totalKills: team.reduce((sum, p) => sum + p.kills, 0),
        score: totalScore,
        ranking: 0 // 将在排序后设置
      });
    }

    // 排序并设置排名
    results.sort((a, b) => b.score - a.score);
    results.forEach((result, index) => result.ranking = index + 1);

    return {
      roomId: room.id,
      duration: Date.now() - room.startTime,
      teamResults: results,
      mvpPlayer: this.findMVP(room.players)
    };
  }

  private calculateTeamScore(team: Player[]): number {
    let score = 0;

    // 撤离奖励
    const evacuatedCount = team.filter(p => p.evacuated).length;
    score += evacuatedCount * 1000;

    // 存活奖励
    const aliveCount = team.filter(p => p.isAlive).length;
    score += aliveCount * 500;

    // 击杀奖励
    const totalKills = team.reduce((sum, p) => sum + p.kills, 0);
    score += totalKills * 100;

    return score;
  }
}
```

### 数据同步
```typescript
// 房间状态同步
class RoomSyncManager {
  async broadcastRoomState(room: GameRoom): Promise<void> {
    const stateData = {
      roomId: room.id,
      state: room.state,
      players: room.players.map(p => ({
        id: p.id,
        teamId: p.teamId,
        isAlive: p.isAlive,
        evacuated: p.evacuated,
        position: p.position
      })),
      evacuationZones: room.evacuationZones,
      timeRemaining: room.timeRemaining
    };

    // 发送给房间内所有玩家
    for (const player of room.players) {
      await this.sendToPlayer(player.id, 'room_state_update', stateData);
    }
  }
}
```

## 依赖关系

### 前置依赖
- **[003] 核心战斗系统**: 需要玩家状态、击杀判定等基础战斗数据
- **[005] AI敌人系统**: 需要AI敌人的状态和行为数据用于游戏进程判定

### 技术依赖
- WebSocket实时通信已建立
- 游戏地图和撤离点数据配置
- 玩家技能评级系统

## 并行开发

**并行状态**: ❌ 不可并行
- 依赖核心战斗系统的玩家状态数据
- 需要AI系统提供的敌人状态信息
- 是其他系统的基础依赖，必须优先完成

## 工作量估算

**总计**: 24小时 (L级)

### 详细分解
- **匹配算法开发** (6小时)
  - 技能匹配算法实现
  - 队列管理和优化

- **房间生命周期** (6小时)
  - 状态机设计和实现
  - 异常处理和回收机制

- **撤离系统实现** (6小时)
  - 撤离点检测和倒计时
  - 中断和重试逻辑

- **胜负判定逻辑** (4小时)
  - 积分计算算法
  - 排名和奖励系统

- **测试和优化** (2小时)
  - 并发压力测试
  - 边界情况验证

## 风险评估

### 高风险
- **并发处理复杂度**: 多房间同时运行可能导致性能问题
- **网络异常处理**: 掉线重连对房间状态的影响

### 中风险
- **匹配算法效率**: 大量玩家时匹配速度可能下降
- **状态同步一致性**: 多客户端状态可能不一致

### 缓解措施
- 实施房间数量限制和动态扩容
- 建立完善的状态恢复和同步机制
- 优化匹配算法，使用缓存和预计算

## 测试策略

### 功能测试
- 各种匹配场景验证（正常、超时、取消）
- 房间生命周期完整流程测试
- 撤离机制准确性验证

### 性能测试
- 多房间并发压力测试
- 匹配算法效率测试
- 内存使用和垃圾回收监控

### 集成测试
- 与战斗系统集成验证
- 网络异常情况处理测试
- 数据一致性验证测试
